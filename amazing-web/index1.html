<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <img id="viewImg" alt="å›¾ç‰‡å°†å‡ºç°åœ¨è¿™é‡Œ"/>

    <video id="video" controls autoplay muted width="640" height="360">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ video æ ‡ç­¾ã€‚
    </video>
</body>
<script>
    (async function() {
        const video = document.getElementById("video");
        const mediaSource = new MediaSource();
        video.src = URL.createObjectURL(mediaSource);

        // åªç»‘å®šä¸€æ¬¡ sourceopenï¼Œé¿å…å¤šæ¬¡æ‰§è¡Œ
        mediaSource.addEventListener("sourceopen", onSourceOpen, { once: true });

        async function onSourceOpen() {
            console.log("ğŸ”“ MediaSource opened");

            // æ ¹æ®ä½ è½¬ç åçš„ H.264 + AAC æ–‡ä»¶å†™ MIME
            const mime = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
            if (!MediaSource.isTypeSupported(mime)) {
                console.error("âŒ MIME ç±»å‹ä¸æ”¯æŒ:", mime);
                return;
            }

            const sourceBuffer = mediaSource.addSourceBuffer(mime);
            // åˆ†æ®µæ¨¡å¼ï¼Œä¸å½±å“æˆ‘ä»¬æ‰‹åŠ¨ append
            sourceBuffer.mode = "segments";

            const response = await fetch("static/test_h264.mp4"); // è¯·ç¡®ä¿è·¯å¾„æ­£ç¡®
            if (!response.body) {
                console.error("âŒ æµè§ˆå™¨ä¸æ”¯æŒæµå¼è¯»å–");
                return;
            }
            const reader = response.body.getReader();

            // ç­‰å¾… SourceBuffer ç©ºé—²
            function waitIdle() {
                return new Promise(resolve => {
                    if (!sourceBuffer.updating) {
                        resolve();
                    } else {
                        sourceBuffer.addEventListener("updateend", resolve, { once: true });
                    }
                });
            }

            let chunkIndex = 0;
            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    console.log("ğŸ“¦ æ‰€æœ‰æ•°æ®è¯»å–å®Œæˆ");
                    // ç¡®ä¿æœ€åä¸€æ¬¡ append å®Œæˆ
                    await waitIdle();
                    if (mediaSource.readyState === "open") {
                        mediaSource.endOfStream();
                        console.log("âœ… endOfStream å·²è°ƒç”¨ï¼Œæ’­æ”¾å®Œæ¯•");
                    }
                    break;
                }

                try {
                    // ç­‰å¾…å‰ä¸€æ¬¡ append å®Œæˆ
                    await waitIdle();
                    sourceBuffer.appendBuffer(value);
                    console.log(`ğŸ“¦ è¿½åŠ ç¬¬ ${++chunkIndex} å—ï¼Œå¤§å°: ${value.byteLength}`);
                } catch (err) {
                    console.error("âŒ è¿½åŠ å¤±è´¥:", err);
                    break;
                }
            }
        }
    })();
</script>
<script type="module">
    import init,{decode_unicode} from "./wasm/amazing_wasm.js";

    async function viewImg() {
        await init();
        const response = await fetch('./static/12179.txt');
        const text = await response.text();
        const byteArray = decode_unicode(text);
        const blob = new Blob([byteArray], { type: 'image/jpeg' });
        const url = URL.createObjectURL(blob);
        const img = document.getElementById('viewImg');
        img.src = url;
    }


    viewImg().catch(err => {
        console.error("è§£ç å¤±è´¥:", err);
    });
</script>
</html>